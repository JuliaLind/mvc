## kmom10


Jag har implementerat PokerSquare spelet som mitt projekt och har gjort samtliga 6 kraven.  


### Krav 1 - 3, Webbplats

Jag valde att inte jobba vidare på den befintliga kodbasen från tidigare kursmoment med kortspel utan har gjort projektet helt och hållet från scratch för att kunna aktivt jobba med kodkvalitén från start (mer om detta under krav 6). Men de nya kunskaperna vi fick under projektets gång och de nya verktygen vi nu hade tillgång till (Scrutinizer, Metrics och även Testning) så tyckte jag att den tidigare skrivna koden inte var särskilt bra. Jag tyckte faktiskt att den var så pass dålig att jag även lade en del tid på att så gott det gick med tiden i åtanke fixa till även den gamla koden för att den inte ska dra ner helhetsintrycket i mätverktygen :), men det var svårare att göra större ändingar i den och blev mer till att faktorisera om och dela upp den befintliga koden i mindre delar och lägga till fler och bättre tester än att ändra i struktur och logik.

De tydligaste skillnaderna mot 21 spelet är bland annat att korten representeras av strängar (jämfört mot egna objekt i 21 spelet), vilket jag upplevde förenklade koden på många ställen. För att underlätta koden ytterligare använder jag inga bokstäver som Rank, utan samtliga kort är på formen "12H" där 12 i detta exempel representerar dam och H hjärter. På så vis har jag inte behövt använda några switch case för att växla mellan namn och värde och jag tycker ändå att dessa förkortningar är enkla att tolka som "alt" text på kortbilderna för människor med synproblem (med tillgänglighet i åtanke). Ett annat exempel är satsning av pengar som hanteras på ett annat sätt - nu väljer användaren belopp att satsa innan spelet initieras och beloppet dras från användarens konto i init routen, vilket gör det omöjligt att fuska och spela en omgång utan att satsa, till skillnad mot 21 spelet där beloppet valdes efter och man kunde fuska genom att gå ur spelet utan att välja belopp och sedan gå in igen.

Kravet på att användaren ska påbörja spelet med att skriva sitt användarnamn har jag tagit ett steg längre och spelaren registrerar sig/loggar in. På så sätt kan användarens "bankkonto" sparas i databasen och kommas åt från olika datorer (mer om detta under krav 6). Användaren loggar in med epostaddress medan acronym (spelarnamn) är vad som visas utåt på Leaderboard. Detta tror jag kan göra det något svårare för någon annan att olovligen logga in på ens konto (eftersom användarnamnet hålls privat). Databasen lagrar inte lösenordet utan lösenordshash som sedan jämförs mot lösenord vid inloggning på samma sätt som vi lärde oss i Webtec kursen. 

Användaren spelar mot huset (mer om detta under krav 6) genom att dra varsitt kort från kortdäcket och placera i varsin grid. Efter varje spelomgång (en omgång = spelare placerar 1 kort, huset placerar ett kort) kontrolleras alla 10 händer för om någon regel är uppfylld (i fallande ordning). Så snart en regel är uppfylld så framgår det tydligt på sidan tillsammans med en preliminär totalpoäng, på så sätt blir det mer motiverande för spelaren att se ens poäng öka (istället för att bara se total på slutet) och mer motiverande att växla in coins mot olika fuskmöjligheter för att försöka få bättre händer (mer om detta under krav 6). En av "fuskmöjligheterna" som användaren kan köpa är förslag på placering för det dragna kortet tillsammans med en uträkning för varje hand på bästa möjliga regel som kan uppnås med kort respektive utan det dragna kortet. Samma logik används även när huset väljer placering för sitt kort (mer om detta under krav 6).  

Om användaren vinner mot huset sparas dennes poäng i en highscore lista. En användare som inte är inloggad kan gå in på Leaderboard via navbaren och se de 10 bästa resultaten (som vunnit mot huset). Jag har valt att inte registera husets poäng när huset vinner. En inloggad användare kan också via en länk på sin profilsida komma in i en vy där denna kan se sina egna 10 bästa scores (vid vinst mot huset). 


Eftersom de "ordinarie" delarna av me-sidan går i skogstema - en stilfull komplementär färgpalett med natuliga gröna nyanser och inslag av höstig orange, och överlag väldigt ljusa och luftiga sidor, har jag valt att göra projektsidorna i mörkt tema med en vågad palett i komplementfärgspar i starka neon-färger, inspirerad av Las Vegas skyltar. Även typsnitten som jag använt till länkarna i navbaren respektive rubrikerna är inspirerade av neonskyltar och skiljer sig tydligt i stil och känsla mot den klassiska Times New Roman som används på de "ordinarie" delarna av webbplatsen.  

I de tidigare kursmomenten där vi arbetade med spelkort använder jag en uppsättning klassiska kort, som jag laddat ner från https://www.me.uk/cards/. Det är en sida där man på ett smidigt sätt kan designa egna kort och till projektet valde jag därför att skapa en helt ny uppsättning i moderna variant som passade in me projektsidornas övriga tema. Jag tog fram helasvarta kort utan bilder med endast tecken och siffror. Hjärter och ruter är i neon-rosa, spader och klöver är neon-lila. Det är samma färger som återkommer på projekt-sidorna. SVG är ett mycket tacksamt format som håller kvaliten oavsett hur stor eller liten skärm som användaren har och det var också smidigt att korten kommer i enskilda svg filer istället för en sammansatt, jag skulle verkligen rekommendera denna sidan för de som ska gå kursen nästa år.

Efter att man klickat in sig på projektet innehåller navbaren enbart länkarna till projektet (löst med separata twig templates för såväl Base-templaten som navbar). Jag hade en tanke på att lägga till en pil tillbaka till den "ordinarie" delen av webbplatsen men eftersom projekt-navbaren enligt instruktion enbart skulle innehålla projektlänkarna så lät jag bli, för att vara på den säkra sidan.

### Krav 4, Json API

Jag har gjort 3 POST routes och 5 GET routes. Jag har använt form-element för både POST och GET för att få ett enhetligt utseende på sidan. 

Get-routen visar diverse data från databasen:

1. data från samtliga tre tabeller för speficik användare
2. de 10 högsta scores balnd samtliga användare
3. alla användare respektive
4. alla transaktioner
5. "current state" av ett pågående Poker Squares spel.  

Post routsen visar ett antal avgränsade delar av logiken som Poker Squares spelet bygger på:  
 
1. Det finns en POST route som man går in på genom att klicka på en slot i en 5x5 grid och i routen får man då se ett nytt grid med ett kort placerat i den sloten man klickat på. Jason objektet visar även de återstående korten i däcket.
2. I en annan POST rout drar en "bot" ett kort varje gång man går in i routen och placerar det i grid i den slot som är mest lämplig enligt samma beräkning som används i det riktiga spelet av huset samt i Suggestion-cheat som spelaren kan köpa. Gridet sparas i sessionen mellan gångerna och när det är helt fyllt börjar allt om från början med en tom grid.   Routen visar vilket kort som plockats upp, vilket slot som föreslogs och griden med kortet placerat i den sloten (och alla kort som placerats i griden tidigare). Routen visar också alla kort som boten kommer att plocka från däcket (i detta fall är det varje kort från toppen förutom de sista 27, eftersom boten ju spelar ensam) och samtliga återstående kort i däcket. För den föreslagna sloten visar json objektet vilka regler som är möjliga att uppnå med kortet horisontellt och vertialt. Vidare visar routen för samtliga 10 händer vilkenr egel som kan uppnås som bäst med det dragan kortet, utan (med enbart korten i respektive hand och de korten som boten kommer få från däcker) och en "väg" värdering som påverkar prioritetsordningen i vilken sloten väljs. Denna rout är mest intressant att gå in på ett natal gånger för att följa botens logik vid kortplaceringar och kan vara väldigt användbar bra om man vill fortsätta optimera spelets logik för att få en mer översiktlig blick kring var man tycker att boten (login bakom Suggestion metoden) gör "mindre bra" val och se var den rprioriteringsvikten kan behöva ytterligare justeringar.
3. I tredje POST routen fylls en 5x5 grid helt och hållet (baserat på samma logik som i andra routen) och därefter beräknas slutresultat/totalpoäng. Även denna logik är bra för att få en översiktlig blick över hur pass bra boten placerat ut kort och vad som hade kunnat göras annorlunda. Routen visar vilka regler som har uppnåtts i samtliga 10 händer och totalpoäng. Routen visar också hela griden och vilka kort som återstår i däcket.

API routsen underlättade en hel del i skapandet av tester, främst när det kom till hårdkodning av ett blandat däck och halvfull grid var det smidigt att copy pastea istället för att skriva ihop dessa på egen hand manuellt. Det gjorde det också enklare att manuellt analysera hur väl "suggestion"-logiken fungerar jämfört mot hur jag själv skulle ha placerat kortet givet kunskapen kring vilka kort som kommer att bli tilldelade mig från däcket.

### Krav 5, ORM  

Jag har skapat tre tabeller i databasen - User, Score och Transaction. 

I user tabellen sparas användaruppgifter för hantering av inloggning (email och lösenordshash) samt akronym som används utåt på Leaderboard. Genom att skilja på användarnamn för inloggning respektive vad utomstående kan se tror jag att det kan ge en lite större säkerhet mot att någon försöker olovligen komma in på ens konto. Om en användare vinner mot huset sparas datum och poäng tillsammans med användarens id i score-tabellen. I transaktions tabellen sparas samtliga transaktioner med datum, kort beskrivning och belopp (positiva siffror innebär att coins ökar på användares konto och negativa innebär att minskning) samt användarens id. Användarens saldo sparas inte i databasen utan beräknas som en summering av samtliga transaktioner registrerade på användarens id. Om jag hade skrivit koden i databasen själv så hade jag kanske istället lagt till ytterligare en kolumn i user och en trigger som vid varje insert i transaction skulle summera värdena i transaktionstabellen och uppdatera värdet i den kolumnen i user tabellen automatiskt, det känns som att det skulle minska antal gånger som kolumnen behöver summeras och även hålla mer av koden i databasen istället för i applikationen.


Samtliga samband är skapade genom att följa instruktionerna i Symfony's dokumentation (jag fick dock göra mindre tweeks i efterhand, exempelvis så föstod jag inte att kolumnen i score / transaction skulle döpas till user så jag döpte den till userid, vilket resulterade i att det faktiskta kolumnnamnet blev userid_id. Detta var dock enkelt att fixa manuellt i efterhand i databasen och i koden för Score respektive Transaction klasserna). Utan tidigare kunskaper i databas hade jag nog upplevt det som svårare att lösa eftersom det inte var särskilt enkelt att hitta information om hur man gör motsvarande ändring i databasen via Symfony. Överhuvudtaget tycker jag att den information som är tillgänglig via Symfony främst behandlar hur man sätter upp något från början och inte hur man ska gå tillväga om man vill ändra/göra om eller ta bort något på "rätt" sätt. 

Primärnyckeln i user tabellen är autoincrementerad siffra och som tidigare nämnt utgör den främmande nyckel i score respektive transaction tabellerna som kopplar datan i dessa till respektive användare. I början hade det genererats även en koppling åt andra hållet (i appen) med hjälp av sk Collection, som jag upplevde som rätt så smidig - tills jag skulle skapa Json routes. Under projektet upptäckte jag att objekt som har getters kan göras om till json direkt utan att hämta ut datan till en associativ array först (och detsamma även för twig templates), vilket minskade mängden kod en hel del, framförallt i API controllers. Detta gick dock inte särskilt bra ihop med Collection attribut som ledde till cirkelreferens-errors. Jag försökte att hitta vädledning i Symfonys dokumentation utan framgång och med tanke på tidbegränsningen samt eftersom det gick lika bra att bara ha referenser åt enbart ett håll och söka på user i Transaction/Score tabellerna så kommenterade jag helt enkelt bort Collection-relaterade delarna. 

 Att arbeta med Symfony-genererade kopplingar visade sig ha vissa besvär i praktiken. Det första problemet jag fick erfara var att om jag vid inloggningen sparade en User i sessionen och senare hämtade ut denne för att lägga till som attribut i en ny transaktion så behandlade EntityManager usern som ”ny” och försökte registrera även denne på nytt i databasen, vilket självfallet gav UniqueConstraintViolationException från databasen eftersom jag satt både email och acronym som unika. Symfony hade absolut inga lättillgänliga artiklar som behandlade detta, utan lösningen som jag hittade via en chat var att enbart spara user idt i sessionen och sedan hämta ut User från databas med hjälp av idt och EntityManager varje gång man vill registrera en transaktion eller score. Detta känns som rätt så onödigt och jag förstår inte varför man skrivit ramverket på detta sätt, när det hade varit tillräckligt för entitesmanagern med en enkel kontroll av getId() för att se om användaren är registrerad eller inte (ej null = registrerad).  

En annan sak jag upplevde problem med var relaterad till testning av databas - när jag skulle kontrollera att registrering av ny användare inte går igenom om det redan finns en användare med samma email eller akronym i databasen.  När jag testade funktionaliteten manuellt så fungerade allt som förväntat och UniqueConstraintViolationException kastades varpå det fångades och ledde till korrekt redirect och flashmeddelande i controller, men när jag skrev tester så lyftes aldrig en exception även om jag precis innan requesten dubbelkollat att det ligger en fixture i databasen med samma email och/eller akronym. Detta gällde såväl vid test av controller som vid test av UserRepository's save metod. För att göra koden testbar fick jag därför byta ut try/catch UniqueConstraintViolationException i controllern som hanterar registrering till att göra sökningar i databasen på akronym respektive epost och redirecta om något av resultaten inte var null. Det kändes som en sämre lösning att göra två förfrågningar till databasen istället för en, men jag valde att ändå prioritera testbarheten.



### Krav 6, Avancerade Features  

Jag börjar med en kortsammanfattning av de optionella sakerna som jag har valt att göra och därefter går jag in mer i detalj på var och en.

#### Sammanfattning:

Jag gjorde båda förslagen till optionella krav som fanns under projektidén Poker Squares - statistik/förslag till spelare samt att huset spelar en omgång emellan. Jag har också, som jag var inne på lite tidigare, skapat stöd för inloggning/registrering så att spelaren kan få tillgång till sitt "bankkonto" från olika datorer och jag har även implementerat en Shop där användaren kan "köpa" mer coins när dessa tar slut. Coins används till att satsa i spelet och till att köpa olika cheats. Samtliga transaktioner registreras i databasen och användaren kan få en tydlig översikt av samtliga historiska transaktioner via en vy som är tillgänglig från dennes profilsida. På så sätt behöver inte kontot bli oanvändbart när alla pengar spelats bort utan man kan fortsätta på samma konto genom att köpa mer coins.  

Det finns totalt fyra olika cheats som användaren kan köpa - ett av dessa är att se statistik (vilka regler som kan uppnås i respektive hand med och utan det tilldelade kortet) samt förslag på bästa placeringen för kortet. Huset spelar enligt samma logik som används i förslag till spelaren. Andra cheats som är tillgängliga är att möjligheten att ångra sista draget (ett drag i taget), att flytta på vilket som helst av korten som redan är placerade i griden och att "tjuvkika" på korten som spelaren kommmer att få tilldelade från däcket. 

Jag har aktivt jobbat med kodkvaliten och kodtäckning med konsekventa avstämningar mot såväl Metrics och Scrutinizer, där jag strävat efter (och uppnått) 100% kodtäckning, i Scrutinizer har jag strävat efter (och uppnått) 10.0 i betyg och även A på samtliga klasser och methoder. I Metrics har jag koncentrat mig på LCOM (max 1 med undantag för klasser som autogenererats av Symfony som fick ha värde på 2), WMC (max 10), Class cycl. (max 10, mina högsta ligger på 7) och Max method cycl. (max 10, mina högsta ligger på 6) och även strävat efter över 90-100 i Maintainability index. Dessa mått inkluderar samtliga klasser från såväl projekt som tidigare kursmoment och inkl både databasklasser och Controllers

#### Statistik till spelare  

Detta tog den absolut längsta tiden att implementera. I och med att jag samtidigt skulle hålla cyclomatisk komplexitet nere fick det inte bli alltför många loopar eller if-checkar. Detta blev såklart lättare när jag upptäckte att jag kunde dela upp koden i små traits men för att inte få för många filer att navigera mellan och logik som ändå hängde ihop var det ändå viktigt att den totala komplexiteten inte skulle dra iväg och bli för svår att följa.  

Logiken består av tre delar:
Dels har vi klasser som avser de olika regler som har metoder för att kontrollera om regeln kan uppnås med det tilldelade kortet givet en specifik hand och de kort som återstår för spelaren att plocka upp ur däcket (vilket är varannat kort minus de två sista - eftersom det ju bara är de första 50 som kommer att plockas upp av huset och spelaren tillsammans) och metod för att kontrollera om regeln kan uppnås utan det tilldelade kortet med den givna handen och korten som återstår att plockas från däcket. En RuleEvaluator klass har alla regelklasserna i en array som attribut och loopar igenom i tur och ordning från regeln som ger mest poäng till regeln som ger minst poäng för att ta reda på vilken regel som kan uppnås som bäst med respektive utan det tilldelade kortet. Det som kommer sen är att bestämma var det är bäst att placera kortet och denna delen skrev jag om ett flertal gånger. Logiken som jag slutligen landade i är: 

Var och en av de 10 händerna får en vägd poäng baserat på:  

1. Poäng för den bästa regel som kan uppnås i handen (med det tilldelade kortet)
2. En extra poäng för varje kort som redan är i handen som bidrar till den regeln (för att prioritera att fylla på påbörjade händer) 
3. Ett halvt extra poäng för en helt tom hand (gör så att tom hand prioriteras över en hand som redan har kort i sig där inga av de redan placerade korten bidrar till regel, samt att tom hand prioriteras när ingen regel kan uppnås överhuvudtaget) 
4. Ytterligare en justering för om den bästa regel som kan uppnås med kortet är Two Pairs eller sämre och den bästa regeln utan kortet är Three Of A kind eller högre. Då justeras poängen ner i relation till poängen som regeln utan kortet kan ge för att prioriteras ner till att väljas efter tom hand och att den hand där bäst regel kan nås utan kortet prioriteras ner sist.  Koden som kontrollerar om en regel kan uppnås med kortet get true om det kortet bidrar till regeln. Så om vi har en tom hand och det tilldelade kortet inte har någon matchning varken i handen eller däcket, och det finns fyra av samma kort i däcket så kommer den inte att ge true på regeln även om kortet i praktiken varken bidrar till eller försökt chanserna att få den bättre regeln. Så här hade man väl egentligen också kunna justera viktningen något med hänsyn till att kortet ger neutralt utfall så att sloten ska priorteras bättre än om kortet skulle förstöra chanserna till att få regeln som var möjlig utan kortet.


Efter kontroll av varje hand väljs de två bästa händerna ut (horizontellt respektive vertikalt) och för var och en av de väljs den bästa tomma placeringen i handen ut med hänsyn till handen i andra riktningen. Dvs att i en horizontell hand kontrolleras varje tom slot för bästa regeln vertikalt, och vice versa för den vertikala bästa handen. Den poängen läggs sedan till för att välja den ena av de två bästa placeringarna.  

Ett alternativ som jag var lite inne på var att göra en motsvarande summering för samtliga lediga slots i griden och välja den bästa, men det hade kunnat ge missvisande resultat om tex four of a kind var möjlig i en riktning och ingen regel i andra riktningen och i en annan slot var Full House möjlig både horisontellt och vertikalt men båda riktningarna var beräknade på samma kort, så var ju i praktiken Full House endast möjlig i ena riktningen och ingen eller sämre regel i andra riktningen. På sättet som jag skrivit tas i första hand hänsyn till den absolut bästa regel åt ett håll och i andra hand bästa placeringen i den handen, vilket vid testning gav bäst slutresultat.  


Denna feature var också svårast att skriva testkod för eftersom mycket behövde hårdkodas för att få så realistiska tester som möjligt, både ett blandat däck, ett delvis fyllt däck och även alla förväntade resultat (vägda poäng), som vid varje ändring behövde skrivas om. Jag hade rätt mycket tester för den "stora" suggestion metoden i början men det blev alldeles för mycket arbete att underhålla efetr varje omskrivning så jag tog bort dessa i ett senare skede, i samband med upptäckten av sambandet mellan traits och testning av privata metoder, och nöjde mig med att testa att de små delmetoderna ger förväntat utfall och att undersöka helhetsbilden manuellt. API routsen som jag skapat för bot plays och för analys av results var till stor hjälp i detta.

#### "Ångra sista draget"-fusk

När spelaren klickar på undo knappen (och förutsatt att denne har tillräckligt med saldo på sitt konto för att transaktionern ska gå igenom) så läggs det senast dragna kortet från däcket tillbaka i slutet på däcket (högst upp). Ovanpå det läggs det senaste placerade kortet av huset. Och sedan lyfts spelarens senast placerade kort så att spelaren kan placera det någon annanstans. Huset får därefter upp samma kort som tidigare och i och med att huset använder samma logik för beräkning och inga faktorer har förändrats så kommer huset att åter igen placera sitt kort på samma ställe som tidigare. Man kan ångra hur många drag som helst ända till en tom grid, men möjligheten försvinner om man använder "flytta på ett kort" fusket (förklarat längre ner) och blir tillgänligt igen nästa gång spelaren palcerar ett kort som kommer direkt från från däcket (efter vilket spelaren endast kan ångra drag som gjorts efter att flytta på ett kort fusket har använts)  

Detta är åstadkommet genom att efter varje drag (från däcket) spara koordinaterna för den slot som sista kortet placerats i, som ett attibut i Game-instansen, t ex [2, 0] för tredje raden och första kolumnen. När draget ångras så lyfts kortet upp från sloten genom att assigna den till en variabel och därefter unset sloten.  

Själva unsettandet hade jag lite svårigheter med innan jag kom på hur jag skulle göra rätt. Om jag tex placerar ett kort på [2, 0] i en tom grid så trodde jag att det skulle räcka med unset($grid[2][0]) för att ta bort både nyckel och värde, men efter ett antal kodkrascher började jag misstänka att det hade något att göra med att nycklar inte togs bort ordentligt. Jag lade till en egen exception som skulle lyftas om den horisontella nyckeln efter borttagning av "kortet" var kopplad till en tom array och det var så jag upptäckte att man först behöver unsetta $grid[2][0] och därefter $grid[2] eftersom det i annat fall ligger kvar en tom array på $grid[2].  

Denna feature skulle man kunna utveckla vidare på och lägga till stöd så att man i samband med använding av "flytta på kort" fusket även loopar igenom och byta ut koordinaterna för det draget/kortet i arrayen med tidigare drag, till de nya koordinaterna. På så sätt skulle inte användaren behöva tänka till en extra gång innan denne använder "flytta på ett kort" fusket. Men jag är ändå supernöjd med den funktionaliteten som är nu, det var enklare att implementera än vad man skulle kunna tro och är riktigt smidig att använda. Först hade jag skrivit koden så att enbart det allra sista draget kunde ångras, men senare kom jag bpå att det bara behövdes ytterst lite kod till för att skapa stöd för ångrande av flera drag.

#### "Flytta på ett kort"-fusk

När spelaren klickar på knappen och frorutsatt att spelaren har tillräckligt med pengar på kontot för att köpa fusket så kommer användaren till en vy där det istället för de tomma slotten går att klicka på sloten med kort. Till skillnad från de andra fusken så registreras inte transaktionen direkt utan först när man valt från vilken ruta man vill flytta kortet . Det blev enklare kod på detta sätt eftersom jag i annat fall hade behövt skapa ytterligare en POST route enbart för registrering av den transaktionen och det kändes som onödigt när jag likväl kunde använda samma POST route för transaktionen som  "från-slotten" registreras i när användaren klickat på det kort som denne vill flytta.  När användaren klickar på en slot med kort så tas denne som sagt till en POST route via vilken from-slot registreras som attribut i Game instansen. Därefter flyttas man till en GET route där spelaren får klicka på en av de tomma slotten som denne vill flytta kortet till, som tar spelaren vidare till en annan POST route som hanterar själva flytten av kortet. Logiken är ungefär samma som i undo funktionalitetn med skillnadenatt kortet då direkt registreras i nya sloten. Denna funktionalitet blev jag också riktigt nöjd med! Även den visade sig vara enklare att implementera än vad man skulle kunna tro och koden i sig skulle kunna användas i fler sammanhang, exempelvis i ett pusselspel.

#### "Smygtitta i däcket"-fusk

Här får spelaren ser vilka kort som återstår för denna att dra ut däcket (varannan kort minus de två sista eftersom spelaren och Huset tillsammans kommer att lyfta de 50 översta korten). Detta är egentligen en del av samma kod som används i funktionalitetn som beräknar statistik.

#### Huset spelar  

Spelaren och huset turas om att dra ett varsitt kort från däcket och placera i griden. Eftersom huset använder samma logik som spelarens "suggestion-cheat" så var det inte jättesvårt att implementera detta, jag skulle faktiskt säga att det var lite enklare än 21 spelet - dels eftersom att antalet kort som ska dras av respektive part är känt i förväg (1) och dels eftersom korten i däcket aldrig kommer att ta slut helt. Jag lade en hel del tid på att försöka implementera en "smartare" logik till huset som alltid skulle ta hänsyn till både regel som kan uppnås med kortet och regel som kan uppnås utan kortet och placera kort där "skadan" blir minst, men i praktiken gav detta sämre slutresultat än logiken för spelaren, då slutplaceringen av korten blev till synes slumpässig med i princip inga relger uppfyllda, så jag tog bort den koden och använde spelarens suggestion-logik istället.  

En idé som jag kom på i slutet var att man för husets del egentlgien hade kunnat i början av spelet beräkna en "mall" över placering av samtliga kort som huset kommer få som ger bästa möjliga utfallet och därefter, under spelets gång, placera varje kort enligt den mallen utan några fler analyser eller beräkningar - en lånsiktig plan helt enkelt som huset håller sig till. På så sätt hade man fått bort en av felkällorna som är närvarande i den nuvarande logiken, nämligen att samma kort räknas in i kontroll mot fler regler, vilket jag misstänker är den största anledningen till att placeringarna inte alltid är optimala. Det hade också minskat ner antal loopar under spelets gång, så det var synd att jag inte kom på detta tidigare, när jag väl fick idén var all kod färdig och jag hade redan skrivit om den så pass många gånger utan att det blev till det bättre att jag inte hade lust eller tid att göra om det ännu en gång.  

Dessutom så laddade jag ner ett spel på telefonen med motsvarande upplägg (att man spelar poker squares mot en bot) för att analysera hur deras bot placerar sina kort och det var ungefär same same, att den gjorde några "missar" precis som min, vilket ju innebar att min logik var "good enough". I detta sammahang kan det egentligen också vara fördelaktigt att huset inte alltid spelar perfekt, så att användaren få en mer genuin upplevelse som påminner mer om att spela mot en riktig spelpartner.

#### Kodtäckning

Jag har 100%-ig kodtäckning, vilket inkluderar samtliga klasser under hela kursen (både från projektet och från alla tidigare kursmoment) inklusive Controllers och Databasklasser. Jag har använt mig av både Unittests och Intergrationstester. 

Ju mer jag arbetade med koden och kodkvalitén desto enklare upplevde jag testningen. Det allra största "breakthough" för min del var när jag upptäckte att privata metoder kunde testas genom att placeras i Traits istället för direkt i klassen. På så sätt kunde jag use traitet av Testklassen och testa methoden med $this->. Detta gjorde att jag inte längre behövde välja mellan att ha många små publika metoder eller en stor publik som anropar många privata och nöja mig med att testa de privata metoderna enbart via den publika - nu kunde jag ha koden uppdelad i hur små bitar som helst, hålla merparten av koden privat och ändå kunna testa små delar i taget, vilket var fantastiskt och underlättade otroligt mycket i framförallt logiken kring förslag på slot/statistik där jag i samband med testning upptäckte flera brister i logiken.  

 Jag har försökt att göra testerna i Controllers så värdefulla som möjligt med både koll mot värden som sparas i session, och i databas (via controller route), att redirects leder rätt och även att rätt flashmeddelanden genereras, och såklart att response är successful samt i viss mån att information på den genererade sidan är förväntad. Jag var dock rätt sparsam med den typen av asserts eftersom det blir rätt omständigt att uppdatera tester pågrund av ändringar i text i templetarna.

När det kommer till testning tycker jag att Symfonys dokumentation är rätt begränsad med få exempel och i flera fall endast delförklaringar. Exempel på det senare är att det enda jag hittade i Symfonys dokumentation kring testning i session var att man kan använda 
```
use Symfony\Component\HttpFoundation\Session\Session;
use Symfony\Component\HttpFoundation\Session\Storage\MockFileSessionStorage;

$session = new Session(new MockFileSessionStorage());
```

och detta var all information som gavs. Hur detta sedan ska implementeras/användas i själva testklassen hittade jag absolut ingen information om, jag lade otroligt mycket tid på att försöka få till det utan framgång. Slutligen så hittade jag via chattforum en trait som en Github användare hade skapat och delat med sig av som kunde användas i Testklasserna för controllers för att mocka en session och lägga till den i clientens container - jag kan säga att jag upplevde koden i den traiten som avancerad och inget som jag kände igen från tidigare kurser, och som jag absolut aldrig skulle ha kunnat sätta ihop själv utifrån den vägledning som Symfony gjort tillgänglig.  

Tyvärr så gav denna trait endast dellösning på mina problem. Traiten gjorde det möjligt att hämta ut och kontrollera data som har sparats i sessionen efter en request, men jag kunde fortfarande inte få till att på förväg spara data där så att den datan kunde hämtas ut från sessionen. Det gick ändå att relativt bra simulera önskat state genom att göra ett antal requests till andra routes innan, men det hade varit mycket smidigare att bara kunna spara en mock med önskade attribut i sessionen direkt.  


Testning av databasen var relativt smidig att komma igång med, även om Symfony, som tidigare nämnt, bettedde sig lite knasigt i vissa sammanhang - detta med att UniqueConstraintViolationException inte lyftes (misstänker att det eventuellt kan ha att göra med att jag lade till att email och acronym kolumnerna skulle vara unika direkt i databasen så Symfony kanske inte "kopierade" över dessa constraints till testdatabasen), samt att testerna i vissa fall verkade hämta ut data från riktiga databasen istället för testdatabasen, men det senare gick som sagt att komma runt detta märkliga beteende genom att uppdaterat datat i Fixtures i testdatabasen.

En annan sak som jag upplevde inte fungerade konsekvent i testning av Controllers var mockning av injectade private services. Om jag gjorde två klasser publika i services_test.yaml på precis samma sätt, och assignade de i clientens container på precis samma sätt, och mockade på precis samma sätt så kunde den ena fungera som förväntat (t ex Mock av DeckOfCards klassen vid testning av en gammal controller från Cards-uppgiften) både avseende antal gånger som viss metod förväntas bli anropas och kontroll mot returvärden. Medan den andra klassen som användes i en annan route gav felmeddelande att metoden som förväntades avnropas en gång i själva verket blev anropad 0 ggr tots att Coverage filen grönmarkerade anropet vilket ju betyder att metoden visst anropats. Jag kom fram till att även här är det klasser som interagerar med databasklasserna (EntityManager) som krånglar. Detta ledde också till att jag fick skriva om koden och ta bort en klass som jag skapat och injectat i controllers enbart för testbarhetens skull eftersom den då inte bidrog till sitt ursrpungliga ändamål.  

Sammanfattningsvis upplevde jag ordinarie klasser och traits som väldigt enkla att testa, PHP har väldigt bra stöd för mockning - bättre än Python av det jag sett hittills. Den enda nackdelen som jag upplevtär att en del metoder som varit tillgängliga tidigare (enligt chatforum) ger deprecation fel och jag lyckades inte hitta vad dessa ersatts med. Ett exmepel är om jag vill kontrollera att en metod hos en klass anropas två gånger, först med en viss uppsättning parametrar och sedan med en annan uppsättning parametrar, så fanns det tidigare en method som hette withConsecutive, men som numera är deprecated. Enbart with blir fel eftersom den bara kan innehålla en "uppsättning" parametrar.  På andra plats kom testning av databas eftersom testerna inte alltid fungerade som förväntat. Testning av controllers var absolut svårast att komma igång med. Symfonys instruktion fungerade inte för mig rakt av utan jag behövde gå in och pilla i fler med olika inställningar enligt vägledning som ajg hittat i chatformum, och även att sätta sig in i hur man testar de olika delarna (mer än att kolla selectortext och att response varit successful) har inte varit särskilt lätt.


#### Kodkvalitet

Jag har aktivt arbetat med kodkvalitet under hela projektets gång och kontrollerat både mot Scrutinizer och Metrics efter i princip varje ändring/tillägg. Förutom att skriva projekt-koden "rätt" från start har jag även gjort viss insats med gammal kod så nedan beskrivna betyg inkluderar samtliga klasser från både projektet och från tidigare kursmoment, inklusive Controllers och Databasklasser.

Det som jag främst koncentrerat mig på i Scrutinizer är:  

1. helhetsbetyg på 10.0
2. att alla klasser/metoder ska ha A i betyg
3. Kodtäckning på 100% utan att exkludera något

[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/JuliaLind/mvc/badges/quality-score.png?b=main)](https://scrutinizer-ci.com/g/JuliaLind/mvc/?branch=main)
[![Code Coverage](https://scrutinizer-ci.com/g/JuliaLind/mvc/badges/coverage.png?b=main)](https://scrutinizer-ci.com/g/JuliaLind/mvc/?branch=main)
[![Build Status](https://scrutinizer-ci.com/g/JuliaLind/mvc/badges/build.png?b=main)](https://scrutinizer-ci.com/g/JuliaLind/mvc/build-status/main)

I Metrics har jag koncentrarat mig på:

1. Att Weighted Method Count ska vara max 10 (högsta för mig är 10, inom enbart projektklasser är högsta 9)
2. Att Class Cyclomatic Complexity dvs cyklomatisk komplexitet på klassnivå  ska vara max 10 (högsta flr mig ligger på 7 men merparten ligger på 1-3 iochmed att jag använder mig av många små traits)
3. Att Max Method Cycolamtic Complexity ska vara max 10, dvs metod med högsta cyclomatiska komplexiteten inom en klass (högsta för mig är 6 men de flesta ligger mellan 0-3).
4. LCOM, dvs värde på klassens ansvar, där 1 motsvarar ett ansvarsområde och 2 betyder att klassen bör delas upp. jag har strävat efter max 1 och klasser som jag skapat själv ligger på 0-1. De fyra autogenerarade Repository-klasserna har 2, och jag lät de vara så eftersom varje gång jag försökte att bättra på något som hade med databasklasser att göra kraschade min kod på ett eller annat sätt. Värst var det vid ett tillfälle när jag försökte att flytta klasser under Entity till andra namespaces för att få bort Packade violation i Metrics. Det verkade inte gå att laga och som tur var hade jag pushat till Github ofta och kunde därför hämta ner den senast fungerade versionen utan alltför mycekt förlorat arbete. Efter denna incident tog jag för vana att vara noga md att båda pusha och tagga senast fungerande version innan alla större ändringar. Jag minns att i Designkursen tyckte jag att pushande till github var ett onödigt steg, men i denna kurs har jag upplevt githib som ett riktigt bra arbetsverktyg. Dessutom har Github Actions upptäckt fel avseende indrag, trailing speaces mm som inte verkar fångas upp av lintern i csfix kommandot, så jag har verkligen uppskattat den extra kontrollen. Och såklart alla automatiska checkar av Scrutinizer vid uppladdningarna. Just när det kommer till LCOM tycker jag egentligen inte att det alltid leder till bättre kod, i vissa fall resulterar det i, enligt mitt tycke, alldeles för små klasser som likväl då hade kunnat vara en fristående funktion, och dessutom delar man upp kod som även om den inte direkt arbetar med samma variabler ändå "makes sence" att hållas ihop för enklare navigering. 

<div class="no-p">
<img src="img/project/metrics-maintainability.png" alt="Metrics maintainability">  
</div>


Min ursprungliga tanke var att även få bort alla Package Violations men det gav jag snabbt upp på - dels så fick man en Stable Depencencies Principle violation så snart man försökte att dela upp en namespace i två för att få lite bättre ordning. Och dels så fick jag dessa varningar på klasser/namespaces som autogenererats av Symfony  (Repository, Entity, DataFixtures) som jag inte vågar röra på i och med att koden bakom är alladeles för abstrakt för att jag ska kunna känna mig trygg i vilka konsekvenser som varje ändring kommer att leda till. Just Stable Abstractions Principle och Stable Dependencies principle upplevde jag att vi inte pratat särskilt mycket alls om i kursen och jag hade gärna velat få tips kring hur man ska tänka för att inte få dessa varningar men ändå kunna hålla god ordning i sin kod utan att ha precis allt i en och samma mapp/namespace. Och även vad dessa varningar faktiskt innebär - spontant hade jag trott att uppdelning av kod eller återanvändning av samma klass i fler namespaces/sammanhang borde betraktas som bra, inte dåligt.



### Projektet

De första fem kraven i porjektet var ganska enkla att genomföra. Det som tog minst tid var nog beräkning av vilka regler som är uppfyllda i händerna - vi hade redan skrivit liknande kod i samband med Jatzy spelet i Python kursen så logiken för flera av reglerna kunde återanvändas.

Krav 6 tog lite väl mycket tid för min del, vilket till stor del berodde på följande saker: 

- Att testa kodkvaliten blev något beroendeframkallande och jag skrev om färdig fungerande kod massvis med gånger för att se om jag kunde förbättre värdena än mer. Därutöver så blev det en rätt stor omskrivning när jag jag upptäckte att jag med hjälp av traits kunde hålla såväl LCOM som cyklomatisk komplexitet nere och samtidigt hålla logik samlad under samma klass istället för att använda fler klasser. I stunden kändes som bara lite extra tid som var värt att lägga för bättre resultat. Men alla större ändringar i koden ledde till att även tester behövde skrivas om, vilket i slutändan resulterade i rätt mycket tid ändå.  

- Även "suggestion"-logiken skrev jag om flera gånger i strävan efter att uppnå bättre placeringsförslag, och varje omskrivning av logiken ledde till att förväntade utfall i testerna behövde uppdateras. Ju mer avancerad logik jag lade till desto mer tester behövdes också göras, och i efterhand när det visade sig att den nya logiken fungerar sämre i praktiken fick jag ändå gå tillbaka till en av de tidigare versionerna. Så från projektets perspektiv blev det rätt mycket tid bortslösad på dessa delar av kod som ändå inte kom till användning. Ur utbildningsperspektiv har jag däremot fått väldigt mycket övning i PHP, att skriva tester och framförallt känner jag att jag börjat få rätt bra känsla för vad som är bra och dålig kod (iallafall enligt mätverktygen som vi använt).

- Den tredje saken som gjorde krav 6 tidskrävande var att försöka hitta rätt information och guidning relaterad till Symfony och ORM, som jag nämnt ovan under Krav 5 och krav 6, framförallt att hitta rätt kring hur jag testar mot session lade jag många timmar på. 
 
I slutändan är jag mycket nöjd med helhets-resultatet och den kunskapen jag tagit till mig under projektets gång. Efter projektet har jag också fått bättre förståelse när det är lämpligt att använda Interface och framförallt vilka otroliga fördelar använding av traits ger. Tex så kan jag, genom att lägga privata metoder i traits, enkelt testa dessa, vilket gör att jag inte behöver välja mellan att göra de publika eller endast testa genom testning av publika metoder som anropar dessa vilket medför att jag kan testa små små bitar av koden enskilt och därmed underlätta felsökning framförallt när det gäller logiska fel. Detta kom särksilt till anvädning i kod som kontrollerar om en regel är möjligt att uppfylla med det tilldelade kortet, framförallt när det kom till möjligheten till att få two pairs regeln eftersom det fanns så många olika möjliga fall att undersöka som inte gick att lägga under en och samma generella logik till skillnad från merparten av de andra reglerna.

Det som jag inte riktigt tyckte om i projekt-upplägget (förutom att krav 6 inte hade tydligare kravspec/riktlinjer) var att vi i denna kurs fortsatte på samma webbplats som me-sidan istället för att bygga helt ny. Eftersom jag valde att skriva all projektrelaterad kod från scratch så var den gamla kdoen/filerna bara till besvär och i vägen, både när det gällde navigering i VScode och att försöka orientera bland mättalen i kodkvalitetsverktygen. 


### Om kursen

Generellt har jag upplevt kursen som något utrspidd och att vi bara hann beröra alla nya delar tillsammans väldigt lätt, men att man ändå föräntades kunna lösa svårare saker, som vi inte gått igenom, på egen hand. Detta skiljde sig från tidigare kurser där såväl ordinarie kursmoment som projekt varit varianter av det vi gått igenom tillsammans.  Om jag hade fått välja hade jag velat ha det lite mer fokuserat på färre områden och att vi djupdök mer i de svårare delarna tillsammans. Framförallt kände jag att vi bara gjorde några få enkla exempel tillsammans avseende Doctrine men att man sedan förväntades kunna mycket mer än så i projektet - en sådan sak var återställning av databas, jag misstänker att sättet som jag löst det på egentligen har en bättre lösning, men inget som jag kunde hitta och Doctrine var överlag inte särskilt intuitivt att arbeta med.

 Som helhetsbetyg är jag ändå nöjd med dena kurs. Innan kursen hade jag rätt begränsade kunskaper i php (egentligen inte mer än loopar och if/else) och nu efter kursen känner jag mig rätt så bekväm med språket och skulle säga att jag kan det på samma nivå som Python och Javascript, vilket är helt klart mycket bättre än vad jag hade kunnat förvänta mig när jag började. Det absolut bästa med kursen var introduktionen till verktygen Scrutinizer och Metrics - det känns jättebra att inte behöva gissa sig till om ens kod är bra eller inte utan få det automatiskt bedömt med tydliga riktlinjer att gå efter, det underlättar arbetet väldigt mycket och det bästa hade varit om vi hade fått använda verktyget redan från kmom01 och i alla kurser (om det nu finns motsvarande verktyg för de andra språken). Att konsekvent arbeta mot verktygen under projektet har också gett mig enganska bra bild för vad som påverkar de olika aspekterna av kodkvaliten och vilken kod som blir lätt respektive svår att testa.  
 
 Om jag tar utgångspunkt i hur mycket jag lärt mig om PHP och kodkvalitet och vilket mervärde kodanalysverktygen kommer att ge mig även i framtida kodskrivande så ger jag kursen 10 av 10. 