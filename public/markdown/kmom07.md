## kmom10


Jag har implementerat PokerSquares spelet som mitt projekt och har gjort samtliga 6 kraven.  


### Krav 1 - 3, Webbplats

Jag valde att inte jobba vidare på den befintliga kodbasen från tidigare kursmoment med kortspel utan har gjort projektet helt och hållet från scratch för att kunna aktivt jobba med kodkvalitén från start (mer om detta under krav 6). 

Med de nya kunskaperna och verktygen vi fått tillgång till under kursens gång (Scrutinizer, Metrics och även Testning) så tyckte jag att den tidigare skrivna koden inte var särskilt bra. Jag tyckte tom att den var så pass dålig att jag även lade en del tid under projektet på att så gott det gick, med tiden i åtanke, fixa till även den gamla koden för att den inte ska dra ner helhetsintrycket i mätverktygen :), men det var svårare att göra större ändringar i den och blev mer till att faktorisera om och dela upp den befintliga koden i mindre delar än att ändra i struktur och logik.

Klasser som hör till projektet är de som ligger i mapparna/namespaces som börjar på ”App\Project…\, controllers som börjar på Project samt alla klasserna under Entity och Repository förutom Book och BookRepository

Några av skillnaderna i implementationen av Poker Squares mot 21 spelet är bland annat att korten representeras av strängar (jämfört mot egna objekt i 21 spelet), vilket jag upplevde förenklade koden på många ställen. För att underlätta koden ytterligare använder jag inga bokstäver som Rank, utan samtliga kort är på formen "12H" där 12 i detta exempel representerar dam och H hjärter. På så vis har jag inte behövt använda några switch case för att växla mellan namn och värde och jag tycker ändå att dessa förkortningar är enkla att tolka som "alt" text på kortbilderna för människor med synproblem (med tillgänglighet i åtanke). Ett annat exempel är satsning av pengar som hanteras på ett annat sätt - nu väljer användaren belopp att satsa innan spelet initieras och beloppet dras från användarens konto i init routen, vilket gör det omöjligt att fuska och spela en omgång utan att satsa, till skillnad mot 21 spelet där beloppet valdes efter att spelet initierats och man kunde fuska genom att gå ur spelet utan att välja belopp och sedan återuppta spelet från startsidan.

Kravet på att användaren ska påbörja spelet med att skriva sitt användarnamn har jag tagit ett steg längre och spelaren registrerar sig/loggar in. På så sätt kan användarens "bankkonto" sparas i databasen och kommas åt från olika datorer (mer om detta under krav 6). Användaren loggar in med epostaddress medan acronym (spelarnamn) är vad som visas utåt på Leaderboard. Detta tror jag kan göra det något svårare för någon annan att olovligen logga in på ens konto (eftersom användarnamnet hålls privat). Databasen lagrar inte lösenordet utan lösenordshash som sedan jämförs mot lösenord vid inloggning på samma sätt som vi lärde oss i Webtec kursen. 

Användaren spelar mot huset (mer om detta under krav 6) genom att dra varsitt kort från kortdäcket och placera i varsin grid. Efter varje spelomgång (en omgång = spelare placerar 1 kort, huset placerar ett kort) kontrolleras alla 10 händer för om någon regel är uppfylld (i fallande ordning). Så snart en regel är uppfylld så framgår det tydligt på sidan tillsammans med en preliminär totalpoäng, på så sätt blir det mer motiverande för spelaren att se ens poäng öka (istället för att bara se total på slutet) och mer motiverande att växla in coins mot olika fuskmöjligheter för att försöka få bättre händer (mer om detta under krav 6). En av "fuskmöjligheterna" som användaren kan köpa är förslag på placering för det dragna kortet tillsammans med en uträkning för varje hand på bästa möjliga regel som kan uppnås med kort respektive utan det dragna kortet. Samma logik används även när huset väljer placering för sitt kort (mer om detta under krav 6).  

Om användaren vinner mot huset sparas dennes poäng i en highscore lista. En användare som inte är inloggad kan gå in på Leaderboard via navbaren och se de 10 bästa resultaten (som vunnit mot huset). Jag har valt att inte registera husets poäng när huset vinner. En inloggad användare kan också via en länk på sin profilsida komma in i en vy där denna kan se sina egna 10 bästa scores (vid vinst mot huset). 


Eftersom de "ordinarie" delarna av me-sidan går i skogstema - en stilfull komplementär färgpalett med natuliga gröna nyanser och inslag av höstig orange, och överlag väldigt ljusa och luftiga sidor, har jag valt att göra projektsidorna i mörkt tema med en vågad palett i komplementfärgspar i starka neon-färger, inspirerad av Las Vegas skyltar. Även typsnitten som jag använt till länkarna i navbaren respektive rubrikerna är inspirerade av neonskyltar och skiljer sig tydligt i stil och känsla mot den klassiska Times New Roman som används på de "ordinarie" delarna av webbplatsen.  

I de tidigare kursmomenten där vi arbetade med spelkort använder jag en uppsättning klassiska kort, som jag laddat ner från https://www.me.uk/cards/. Det är en sida där man på ett smidigt sätt kan designa egna kort och till projektet valde jag därför att skapa en helt ny uppsättning i modernare variant som passade in me projektsidornas övriga tema. Jag tog fram helsvarta kort utan bilder med endast tecken och siffror. Hjärter och ruter är i neon-rosa, spader och klöver är neon-lila. Det är två av de fem färgerna som återkommer på projektsidorna. SVG är ett mycket tacksamt format som håller kvaliten oavsett hur stor eller liten skärm som användaren har och det var också smidigt att korten kommer i enskilda svg filer istället för en sammansatt, jag skulle verkligen rekommendera denna sidan för de som ska gå kursen nästa år.

Efter att man klickat in sig på projektet innehåller navbaren enbart länkarna till projektet (löst med separata twig templates för såväl Base-templaten som navbar). Jag hade en tanke på att lägga till en pil tillbaka till den "ordinarie" delen av webbplatsen men eftersom projekt-navbaren enligt instruktion enbart skulle innehålla projektlänkarna så lät jag bli, för att vara på den säkra sidan.

### Krav 4, Json API

Jag har gjort 3 POST routes och 5 GET routes. Jag har använt form-element för både POST och GET för att få ett enhetligt utseende på sidan. 

Get-routen visar diverse data från databasen:

1. Sammansatt data från samtliga tre tabeller kopplad till en specifik användare
2. de 10 högsta scores bland samtliga användare
3. alla användare
4. alla transaktioner
5. "current state" av ett pågående Poker Squares spel.  I redovisningsvideon visar jag att man i denna route kan se statistik för spelaren och jag vill tillägga här att den statistiken ser man bara efter att man köpt ett "suggestion" innan man placerar kortet - för att undvika "onödiga" loopar så generareras statistik och suggestion bara när du ”köper” den cheaten, och nollställs därefter så snart du placerar ett kort i griden. Om du använder Post-routen för ”bot plays”, beskriven längre ner, kan du där se motsvarande statistik-beräkning

Post routsen visar ett antal avgränsade delar av logiken som Poker Squares spelet bygger på:  
 
1. Det finns en POST route som man går in på genom att klicka på en slot i en 5x5 grid och i routen får man då se ett nytt grid med ett kort placerat i den sloten man klickat på. Json objektet visar även de återstående korten i däcket.
2. I en annan POST rout drar en "bot" ett kort varje gång man går in i routen och placerar det i grid i den slot som är mest lämplig enligt samma statistik-beräkning som används i det riktiga spelet av huset samt i Suggestion-cheat som spelaren kan köpa. Gridet sparas i sessionen mellan gångerna och när det är helt fyllt börjar allt om från början med en tom grid.  Routen visar vilket kort som plockats upp, vilken slot som föreslogs och griden med kortet placerat i den sloten (och alla kort som placerats i griden tidigare). Routen visar också alla kort som boten kommer att plocka från däcket (i detta fall är det varje kort från toppen förutom de sista 27, eftersom boten ju spelar ensam) och samtliga återstående kort i däcket. För den föreslagna sloten visar json objektet vilken regel som är möjliga  att som bäst uppnå med kortet horisontellt respektive vertikalt. Vidare visar routen för samtliga 10 händer vilken regel som kan uppnås som bäst med det dragna kortet, utan (med enbart korten i respektive hand och de korten som boten kommer få från däcket) och en "weight" värdering som påverkar prioritetsordningen i vilken sloten väljs. Denna rout är mest intressant att gå in på ett antal gånger för att följa botens logik vid kortplaceringar och kan vara väldigt användbar om man vill fortsätta optimera spelets logik för att få en mer överskådlig blick över var man tycker att boten (login bakom Suggestion metoden) gör "mindre bra" val och se var den prioriterings-vikten kan behöva ytterligare justeringar.
3. I tredje POST routen fylls en 5x5 grid helt och hållet (baserat på samma logik som i andra routen) och därefter beräknas slutresultat/totalpoäng. Även denna route är bra för att få en översiktlig blick över hur pass bra boten placerat ut kort och vad som hade kunnat göras annorlunda. Routen visar vilka regler som har uppnåtts i samtliga 10 händer och totalpoäng. Routen visar också hela griden och vilka kort som återstår i däcket.

API routsen underlättade en hel del i skapandet av tester, främst när det kom till hårdkodning av ett blandat däck och halvfull grid var det smidigt att copy pastea istället för att skriva ihop dessa på egen hand manuellt. Det gjorde det också enklare att manuellt analysera hur väl "suggestion"-logiken fungerar jämfört mot hur jag själv skulle ha placerat kortet givet kunskapen kring vilka kort som kommer att bli tilldelade mig från däcket.

### Krav 5, ORM  

Jag har skapat tre tabeller i databasen - User, Score och Transaction. Projektet är designat så att man (vid normal användning) bara kan lägga till data i de projekt-relaterade tabellerna i databasen, inte ändra eller ta bort. Det smidigaste sättet att återställa projekt-databasen är via knappen som finns längst ner på sidan /proj/about/database . När man klickar på den är det filen reset-proj.sql som ligger under public/sql som läses in och då återställs endast tabellerna som är kopplade till projektet. Om man har laddat ner projektet lokalt kan man också återställa databasen genom att via terminalen läsa in backup.sql, då återställs hela databasen inkl tabellen som hör till Library-uppgiften. 

I user tabellen sparas användaruppgifter för hantering av inloggning (email och lösenordshash) samt akronym som används utåt på Leaderboard. Genom att skilja på användarnamn för inloggning respektive vad utomstående kan se tror jag att det kan ge en lite större säkerhet mot att någon försöker olovligen komma in på ens konto. Om en användare vinner mot huset sparas datum och poäng tillsammans med användarens id i score-tabellen. I transaktions tabellen sparas samtliga transaktioner med datum, kort beskrivning och belopp (positiva siffror innebär att coins ökar på användares konto och negativa innebär att minskning) samt användarens id. Användarens saldo sparas inte i databasen utan beräknas som en summering av samtliga transaktioner registrerade på användarens id. Om jag hade skrivit koden i databasen själv så hade jag kanske istället lagt till ytterligare en kolumn i user och en trigger som vid varje insert i transaction skulle summera värdena i transaktionstabellen och uppdatera värdet i den kolumnen i user tabellen automatiskt, det känns som att det skulle minska antal gånger som kolumnen behöver summeras och även hålla mer av koden i databasen istället för i applikationen.


Samtliga samband är skapade genom att följa instruktionerna i Symfony's dokumentation (jag fick dock göra mindre tweeks i efterhand, exempelvis så föstod jag inte att kolumnen i score / transaction skulle döpas till user så jag döpte den till userid, vilket resulterade i att det faktiskta kolumnnamnet blev userid_id. Detta var dock enkelt att fixa manuellt i efterhand i databasen och i koden för Score respektive Transaction klasserna). Utan tidigare kunskaper i databas hade jag nog upplevt det som svårare att lösa eftersom det inte var särskilt enkelt att hitta information om hur man gör motsvarande ändring i databasen via Symfony. Överhuvudtaget tycker jag att den information som är tillgänglig via Symfony främst behandlar hur man sätter upp något från början och inte hur man ska gå tillväga om man vill ändra/göra om eller ta bort något på "rätt" sätt. 

Primärnyckeln i user tabellen är autoincrementerad siffra och som tidigare nämnt utgör den främmande nyckel i score respektive transaction tabellerna som kopplar datan i dessa till respektive användare. I början hade det genererats även en koppling åt andra hållet (i appen) med hjälp av sk Collection, som jag upplevde som rätt så smidig - tills jag skulle skapa Json routes. Under projektet upptäckte jag att objekt som har getters kan göras om till json direkt utan att hämta ut datan till en associativ array först (och detsamma även för twig templates), vilket minskade mängden kod en hel del, framförallt i API controllers. Detta gick dock inte särskilt bra ihop med Collection attribut som ledde till cirkelreferens-errors. Jag försökte att hitta vädledning i Symfonys dokumentation utan framgång och med tanke på tidbegränsningen samt eftersom det gick lika bra att bara ha referenser åt enbart ett håll och söka på user i Transaction/Score tabellerna så kommenterade jag helt enkelt bort Collection-relaterade delarna. 

 Att arbeta med Symfony-genererade kopplingar visade sig ha vissa besvär i praktiken. Det första problemet jag fick erfara var att om jag vid inloggningen sparade en User i sessionen och senare hämtade ut denne för att lägga till som attribut i en ny transaktion så behandlade EntityManager usern som ”ny” och försökte registrera även denne på nytt i databasen, vilket självfallet gav UniqueConstraintViolationException från databasen eftersom jag satt både email och acronym som unika. Symfony hade absolut inga lättillgänliga artiklar som behandlade detta, utan lösningen som jag hittade via en chat var att enbart spara user idt i sessionen och sedan hämta ut User från databas med hjälp av idt och EntityManager varje gång jag vill registrera en transaktion eller score och därefter lägga till som attribut i den nya transaction/score instansen. Detta löste problemet men känns inte som en särskilt bra lösning egentligen, när det hade varit tillräckligt för entitesmanagern med en enkel kontroll av getId() för att se om användaren är registrerad eller inte (ej null = registrerad). Och om man nu ändå måste hämta ut User från databas varje gång så hade det varit bättre att tranction/score instanserna hade enbart integern user_id som attribut, inte hela user-objektet. Som koden är skriven nu så underlättar det bara i de fall user och transaction behöver registreras samtidigt - när jag registrerar transaktioner eller scores för befintliga användare blir det en extra förfrågan till databasen varje gång, helt i onödan.

En annan sak jag upplevde problem med var relaterad till testning av databas, när jag skulle kontrollera att registrering av ny användare inte går igenom om det redan finns en användare med samma email eller akronym i databasen.  När jag testade funktionaliteten manuellt så fungerade allt som förväntat och UniqueConstraintViolationException kastades varpå det fångades och ledde till korrekt redirect och flashmeddelande i controller, men när jag skrev tester så lyftes aldrig en exception även om jag precis innan requesten dubbelkollat att det ligger en fixture i databasen med samma email och/eller akronym. Detta gällde såväl vid test av controller som vid test av UserRepository's save metod. För att göra koden testbar fick jag därför byta ut try/catch UniqueConstraintViolationException i controllern som hanterar registrering till att göra sökningar i databasen på akronym respektive epost och redirecta om något av resultaten inte var null. Det kändes som en sämre lösning att göra tre förfrågningar till databasen istället för en, men jag valde att ändå prioritera testbarheten. Jag misstänker att detta eventuellt kan ha något att göra med att jag lade till unique constraint manuellt i databasen i efterhand och att det kanske därför inte kopierades över till testdatabasen när jag skapade motsvarande tabeller i testdatabasen via Symfony.



### Krav 6, Avancerade Features  

Jag börjar med en kortsammanfattning av de optionella sakerna som jag har valt att göra och därefter går jag in mer i detalj på var och en.

#### Sammanfattning:

Jag gjorde båda förslagen till optionella krav som fanns under projektidén Poker Squares - statistik/förslag till spelare samt att huset spelar en omgång emellan. Jag har också, som jag var inne på lite tidigare, skapat stöd för inloggning/registrering så att spelaren kan få tillgång till sitt "bankkonto" från olika datorer och jag har även implementerat en Shop där användaren kan "köpa" mer coins när dessa tar slut. Coins används till att satsa i spelet och till att köpa olika cheats och jag har skapat en bra flödeskontroll som gör så att användaren inte får tillgång till cheatsen om denne inte har tillräckligt med pengar på kontot. Skulle spelaren försöka nå en sådan route direkt via urlen så blir denne re-directad tillbaka till spelet (eller till profilsidan om inget spel har startat). Samtliga transaktioner registreras i databasen och användaren kan få en tydlig översikt över hela transaktionshistoriken via en vy som är tillgänglig från dennes profilsida. På så sätt behöver inte kontot bli oanvändbart när alla pengar spelats bort utan man kan fortsätta på samma konto genom att köpa mer coins.  

Det finns totalt tre olika cheats som användaren kan köpa - ett av dessa är att se statistik (vilka regler som kan uppnås i respektive hand med och utan det tilldelade kortet) samt förslag på bästa placeringen för kortet och vilka kort som spelaren kommer att plocka från däcket under resten av spelet. Andra cheats som är tillgängliga är att möjligheten att ångra senaste draget (fungerar hela vägen tillbaka till en tom grid) och att flytta på vilket som helst av korten som redan är placerade i griden (kan också användas hur många gånger som helst så länge griden innehåller minst ett kort och det finns minst en ledig slot). 

Jag har aktivt jobbat med kodkvaliteten och testbarhet med konsekventa avstämningar mot såväl Metrics och Scrutinizer. Jag har strävat efter (och uppnått) 100% kodtäckning, i Scrutinizer har jag strävat efter (och uppnått) 10.0 i betyg och även A på samtliga klasser och methoder. I Metrics har jag koncentrat mig på LCOM (max 1 med undantag för klasser som autogenererats av Symfony som fick ha värde på 2), Class cycl. (max 10, mina högsta ligger på 7) och Max method cycl. (max 10, mina högsta ligger på 6) och även strävat efter över 90-100 i Maintainability index. Dessa mått inkluderar samtliga klasser från såväl projekt som tidigare kursmoment och inkl både databasklasser och Controllers.

De valda punkterna är rätt sammankopplade och har därför ökat svårighetsgraden hos varandra (t ex att det blir mer och svårare att testa ju mer avancerad logik som sker i val av bästa slot och att alla extra features har krävt extra controller-routes och därmed ochså mer testkod). Utöver dessa punkter har jag även arbetat med användarvänligheten genom att göra aktiva val i designen avseende placering och avstånd mellan element, färgsättning och animeringar (css effekter), för att det ska kännas naturligt för användaren vad denne behöver klicka på och när. Jag har också bra felhantering i routerna och lagt in felkontroller även i get routes som redirectar användaren på ett bra sätt om denne direkt via url går in i en route som är tänkt att accessas endast via knappar. Jag har även sett till att lägga in så att en inloggad användare ska loggas ut automatiskt i samband med återställning av databasen för att sidan inte ska krascha om man återställer databasen efter att ha registrerat sig och loggat in som en ny användare.





#### Statistik och förslag på kort-placering till spelare  


Denna cheat ger information om följande saker:
För samtliga 10 händer vilken regel som kan uppnås som bäst om det tilldelade kortet placeras i den handen (där det tilldelade kortet bidrar till regeln)
För samtliga 10 händer vilken regel som kan uppnås som bäst om det tilldelade kortet inte placeras i den handen
Koordinater (rad, kolumn)  för den (tomma) sloten som enligt beräkningar är den bästa placeringen för det tilldelade kortet


Logiken består av tre delar:

1. Varje regel är en egen klass som förutom metod för att kontrollera om en hand uppnått en regel också har metoder för att kontrollera vilka regler som kan uppnås som bäst med respektive utan det tilldelade kortet. I metoden som kontrollerar för regel med kortet görs den första “vägningen” av handen som beräknar extra poäng baserat på hur många av korten i handen som bidrar till just den regeln. Detta för att en hand med exempelvis tre kort som bidrar till regeln ska prioriteras över en hand där bara ett av korten bidrar till regeln. Detta bidrar dels till att logiken i första hand prioriterar att “göra färdigt” en redan börjad hand framför en ny eller en hand där fler av korten bidrar till annan regel. Beräkningarna bygger på förutom korten i handen även de kort i däcker som spelaren kommer att plocka under resten av spelet, dvs vartannat kort minus de två sista, eftersom det ju bara är de första 50 som kommer att plockas upp av huset och spelaren tillsammans. Koden som kontrollerar om en regel kan uppnås med kortet ger true endast om det kortet bidrar till regeln. Tex om handen innehåller en 4a och en 5a, du har blivit tilldelat en 7a från däcket, och bland korten som är kvar i däcket finns en 5a och en 7a, då kommer suggestion ge true på att regeln one Pair kan uppnås med kortet. Medan om däcket inte skulle ha innehållit någon 7a men däremot en till 4a och 5a så blir det false eftersom 7an ju inte skulle bidra till den two pairs regeln, även om den inte heller förstör chanserna till att få den.  Här hade man väl egentligen kunna ge någon liten extra vikt med hänsyn till att kortet ger neutralt utfall så att sloten ska priorteras bättre än om kortet skulle förstöra chanserna till att få regeln som var möjlig utan kortet.
2. En RuleEvaluator klass har alla regelklasserna i en array som attribut och loopar igenom i tur och ordning från regeln som ger mest poäng till regeln som ger minst poäng för att ta reda på vilken regel som kan uppnås som bäst med respektive utan det tilldelade kortet för varje hand. 
3. I Rule Evaluatorn klassen vägs alla händer för att skapa en prioritetsordning för slot-förslaget. Denna del av logiken var svårare än vad jag först hade räknat med och jag skrev om den flera gånger. Logiken som jag slutligen landade i och som i de flesta fall faktiskt tar smarta beslut är: 

1. Utgångspunkten är 0.5 poäng för en helt tom hand eller 0 för en delvis fylld. Det gör att en tom hand utan möjlighet till regel prioriteras över en påbörjad hand utan möjlighet till regel för att inte förstöra möjlighet till eventuell annan regel som påbörjats i den handen, men kommer inte att väga tyngre än en påbörjad hand med minst ett kort som bidrar till regeln (punkt 3)
2. Om en regel är möjlig så läggs regelns poäng till.
3. För varje kort i handen som bidrar till den regeln läggs ytterligare ett poäng. 
4. Ytterligare en justering görs för om den bästa regel som kan uppnås med kortet är Two Pairs eller sämre och den bästa regeln utan kortet är Three Of A Kind eller högre. Då justeras poängen ner i relation till poängen som regeln utan kortet kan ge för att prioriteras ner till att väljas efter tom hand och att den hand där bäst regel kan nås utan kortet prioriteras ner sist.   
5. Efter kontroll av alla 10 händer väljs de två bästa händerna ut (en horizontellt och en vertikalt) och för var och en av de väljs den bästa tomma placeringen i handen ut med hänsyn till handen i andra riktningen. Dvs att i en horizontell hand kontrolleras varje tom slot för bästa regeln vertikalt, och vice versa för den vertikala bästa handen. Den poängen läggs sedan till för att välja den ena av de två bästa placeringarna. Ett alternativ som jag också var lite inne på var att göra en motsvarande summering för samtliga lediga slots i griden och välja den bästa, men det hade kunnat ge missvisande resultat om tex four of a kind var möjlig i en riktning och ingen regel i andra riktningen och i en annan slot var Full House möjlig både horisontellt och vertikalt men båda riktningarna var beräknade på samma kort, så var ju i praktiken Full House endast möjlig i ena riktningen och ingen eller sämre regel i andra riktningen. På sättet som jag skrivit tas i första hand hänsyn till den absolut bästa regel åt ett håll och i andra hand bästa placeringen i den handen, vilket vid testning gav bäst slutresultat.  

Detta har varit den absolut mest tidskrävande delen av projektet och har även varit utmanande att lösa tankemässigt. I och med att jag samtidigt skulle hålla cyclomatisk komplexitet nere (då jag även valt att jobba med kodkvaliteten) fick det inte bli alltför många loopar eller if-checkar. Detta blev såklart lättare när jag upptäckte att jag kunde dela upp koden i små traits men för att logiken skulle bli lätt att följa och testa även som helhet var det ändå viktigt att den totala komplexiteten inte skulle dra iväg och bli för svår att förstå eller förklara (här tänker jag främst på beräkning av bästa placering för kortet). 

Denna feature var också mest tidskrävande att skriva testkod för eftersom mycket behövde hårdkodas för att få så realistiska tester som möjligt, både invärden och förväntade resultat (vägda poäng), som vid varje ändring i logik och beräkning behövde uppdateras (även om API routsen som jag skapat för bot plays och för analys av results var till stor hjälp). Jag hade rätt mycket tester för den "stora" suggestion metoden i början men det blev alldeles för mycket arbete att underhålla efter ett tag så jag tog bort dessa i ett senare skede, i samband med upptäckten av sambandet mellan traits och testning av privata metoder, och nöjde mig med att testa att de små delmetoderna ger förväntat utfall och några få automatiska tester för helheten, och att istället göra fler manuella tester av logiken eftersom det var enklare att se helhetsbilden på det sättet. Jag har också uppfattat det som lättare att upptäcka logiska fel genom att komplettera automatiska tester med manuella, eftersom det ju är jag själv som skrivit logiken i de manuella testerna. 

Att kunna se vilka kort som man kommer att få upp från däcket skrev jag först som en egen cheat med egna routes men sedan kom jag fram till att det gav mer värde för spelaren att se dessa samtidigt som den övriga statistiken (och framförallt för mig själv vid den manuella testningen av logiken för slot-förslaget) och skrev om koden så att båda blev sammanslagna i en och samma vy.

#### "Ångra sista draget"-fusk

När spelaren klickar på undo knappen (och förutsatt att denne har tillräckligt med saldo på sitt konto för att genomföra köpet) så läggs det senast dragna kortet från däcket tillbaka i slutet på däcket (högst upp). Ovanpå det läggs det senaste placerade kortet av huset. Och sedan lyfts spelarens senast placerade kort så att spelaren kan placera det någon annanstans. I och med att huset använder samma logik för val av slot som suggestion-cheat och inga faktorer har förändrats så kommer huset att åter igen placera sitt kort på samma ställe som tidigare, så att ångra ett drag kommer inte att påverka Husets utfall. Man kan ångra hur många drag som helst ända till en tom grid, men möjligheten försvinner om man använder "flytta på ett kort" fusket (förklarat längre ner) och blir tillgänligt igen nästa gång spelaren placerar ett kort som kommer direkt från från däcket (efter vilket spelaren endast kan ångra drag som gjorts efter att “flytta på ett kort” fusket har använts):  

Detta är åstadkommet genom att efter varje drag (från däcket) spara koordinaterna för placeringen, i en array i Game-instansen (en för spelaren och en för huset), t ex [2, 0] för tredje raden och första kolumnen. När draget ångras så lyfts kortet upp från sloten genom att assigna den till en variabel och därefter unset sloten.  Och placeringen “pop”as från arrayen så att det föregående draget ångras nästa gång spelaren klickar på “undo”. 

Själva unsettandet hade jag lite svårigheter med innan jag kom på hur jag skulle göra rätt. Om jag tex placerar ett kort på [2, 0] i en tom grid så trodde jag att det skulle räcka med unset($grid[2][0]) för att ta bort både nyckel och värde, men efter ett antal kodkrascher började jag misstänka att det hade något att göra med att nycklar inte togs bort ordentligt. Jag lade till en egen exception som skulle lyftas om den horisontella nyckeln efter borttagning av "kortet" var kopplad till en tom array och det var så jag upptäckte att man först behöver unsetta $grid[2][0] och därefter $grid[2] eftersom det i annat fall ligger kvar en tom array på $grid[2].  

Denna feature skulle man kunna utveckla vidare på och lägga till stöd så att man i samband med använding av "flytta på kort" fusket även loopar igenom och byta ut koordinaterna för det draget/kortet i arrayen med tidigare drag, till de nya koordinaterna. På så sätt skulle inte användaren behöva tänka till en extra gång innan denne använder "flytta på ett kort" fusket. Men jag är ändå supernöjd med den funktionaliteten som är nu och hur smidigt den fungerar.  

Även denna feature var tidskrävande att implementera och jag gjorde implementeringen i flera steg. Först hade jag skrivit koden så att enbart det allra sista draget kunde ångras, men senare utvecklade jag featuren till att möjliggöra flera steg bakåt.

#### "Flytta på ett kort"-fusk

När spelaren klickar på knappen och förutsatt att spelaren har tillräckligt med pengar på kontot för att köpa fusket så kommer användaren till en vy där det istället för de tomma slotten går att klicka på sloten med kort. Till skillnad från de andra fusken så registreras inte transaktionen direkt utan först i samband med att kortet faktiskt flyttas. Dels blev det enklare kod på detta sätt eftersom jag i annat fall hade behövt skapa ytterligare en POST route enbart för registrering av den transaktionen och på detta sätt kunde jag använda samma route för registrering av transaktionen som flytten genomförst i, och dels kändes det inte helt rättvist att ta betalt innan tjänsten faktiskt utnyttjas (om användaren t ex skulle gå ur spelet mitt i).  

När användaren klickar på en slot med kort så tas denne till en POST route via vilken from-slot registreras som attribut i Game instansen. Därefter flyttas soelaren till en GET route där denne får klicka på en av de tomma slotten som denne vill flytta kortet till, som tar spelaren vidare till en annan POST route som hanterar själva flytten av kortet. Logiken har en del likheter med logiken för undo med skillnaden att kortet här direkt registreras i nya sloten och att inget sker i husets geid, samt att funtkionaliteten använder sig av två get- och två post-routes, medan undo enbart använder sig av en post-route. Denna funktionalitet blev jag också riktigt nöjd med och koden i sig är rätt generell och skulle kunna användas i fler sammanhang, exempelvis i ett pusselspel.

Det svåraste med denna feature var att skapa en bra felhantering för om användaren går ur routen efter att flytten påbörjats men inte genomfört, och jag gjorde om lösningen ett antal gånger innan jag landade i nuvarande lösning. 


#### Huset spelar  

Spelaren och huset turas om att dra ett varsitt kort från däcket och placera i griden.  Jag anser att detta ska räknas in under krav 6 eftersom denna feature komplicerar koden överlag exempelvis vid beräkning av statistik och i "undo"-cheat. Ursprungligen skrev jag också en separat logik till huset, som alltid jämförde regel med och utan kort och valde slotten den mest fördelaktiga mellanskillnaden, som jag lade en hel del tid på (vilket syns i min <a href="https://github.com/JuliaLind/mvc/commits?after=81cc95ba761a1878e0a39a5cbefdf16061ca719e+104&author=JuliaLind">Github historik</a>), men det upplägget gav inte det förväntade resultatet utan resulterade i spretig placering där få regler blev uppfyllda överhuvudtaget, så i slutändan fick jag ta bort den koden och låta huset spela med samma logik som spelarens suggestion-cheat iallafall.

Jag är ändå nöjd med min lösning. För att undersöka hur väl huset spelar i ”riktiga” spelappar har jag laddat ner ett spel på telefonen med motsvarande upplägg (att man spelar poker squares mot en bot) för att analysera hur deras bot placerar sina kort och det var ungefär same same, att den gjorde några "missar" precis som min, vilket ju innebar att min logik var "good enough". I detta sammahang kan det egentligen också vara fördelaktigt att huset inte alltid spelar perfekt, så att användaren får en mer genuin upplevelse som påminner mer om att spela mot en riktig spelpartner.  


En idé som jag tyvärr kom på först i slutet var att man för husets del egentligen hade kunnat i början av spelet beräkna en "mall" över placering av samtliga kort som huset kommer få som ger bästa möjliga utfallet totalt sett och ”öronmärka” respektive slot för att därefter, under spelets gång, placera varje kort enligt den mallen utan några fler analyser eller beräkningar - en lånsiktig plan helt enkelt som huset håller sig till. På så sätt hade man fått bort en av felkällorna som är närvarande i den nuvarande logiken, nämligen att samma kort räknas in i kontroll mot fler regler, vilket jag misstänker är den största anledningen till att placeringarna inte alltid är optimala. Det hade också minskat ner antal loopar under spelets gång, så det var synd att jag inte kom på detta tidigare, när jag väl fick idén var all kod färdig och jag hade redan skrivit om den så pass många gånger utan att det blev till det bättre att jag inte hade lust eller tid att göra om det ännu en gång.  




#### Kodtäckning

Jag har 100%-ig kodtäckning, vilket inkluderar samtliga klasser under hela kursen (både från projektet och från alla tidigare kursmoment) inklusive Controllers och Databasklasser. Jag har använt mig av unittests, intergrationstester och aplikationstester. Att välja full täckning som en av extrapunkterna var ett självklart val för mig då det även ger extra trygghet i att de övriga kraven fungerar som det ska. Särskilt testning av controllers var till stor hjälp eftersom det är så lätthänt att man råkar lägga in fel path i en länk/knapp i template och sedan missar att klicka på den vid manuell testning. Ett controller-test kraschar däremot direkt när templaten  innehåller referens till en path eller variabel som inte finns. 

Jag tycker att denna punkt ska räknas in under krav 6 eftersom enligt Mikaels kommentar i chatten så var grundkravet att man skulle sikta på 90 % i den ordinarie klasserna och att det inte behövdes för databasklasser och controllers. Att skriva tester var väldigt tidskrävande överlag i och med alla extrafeatures som jag implementerat och även pågrund av att jag skrev om koden många gånger för att bättra på kvalitén (nästa punkt) och vid i princip alla ändringar så följde ett stort jobb med att även uppdatera i tester. Jag upplevde också att Symfonys dokumentation avseende testning är rätt begränsad med få exempel och i flera fall endast delförklaringar, så att hitta relevant information för “mer avancerade” tester tog också rätt mycket tid i anspråk. Exempel på det är att det enda jag hittade i Symfonys dokumentation kring testning med session var att man kan använda 
```
use Symfony\Component\HttpFoundation\Session\Session;
use Symfony\Component\HttpFoundation\Session\Storage\MockFileSessionStorage;

$session = new Session(new MockFileSessionStorage());
```

och detta var all information som gavs. Hur detta sedan ska implementeras/användas i själva testklassen hittade jag absolut ingen information om, jag lade otroligt mycket tid på att försöka få till det utan framgång. Slutligen så hittade jag via chattforum en trait som en Github användare hade skapat och delat med sig av som kunde användas i Testklasserna för controllers för att mocka en session och lägga till den i clientens container - jag kan säga att jag upplevde koden i den traiten som avancerad och inget som jag kände igen från tidigare kurser, och som jag absolut aldrig skulle ha kunnat sätta ihop själv utifrån den vägledning som Symfony gjort tillgänglig.  

Tyvärr så gav denna trait endast dellösning på mina problem. Traiten gjorde det möjligt att hämta ut och kontrollera data som har sparats i sessionen efter en request, men jag kunde fortfarande inte få till att på förväg spara data där så att den datan kunde hämtas ut från sessionen. Det gick ändå att relativt bra simulera önskat state genom att göra ett antal requests till andra routes innan, men det hade varit mycket smidigare att bara kunna spara en mock med önskade attribut i sessionen direkt.  


Jag gjorde iallafall mitt bästa för att göra testerna i Controllers så värdefulla som möjligt med både koll mot värden som sparas i session (t ex att undo roten verkligen genomföra ändringen i spelet och att det uppdaterade spelet soaras i sessionen), och i databas (via controller route), att redirects leder rätt och även att rätt flashmeddelanden genereras, och såklart att response är successful samt i viss mån att information på den genererade sidan är förväntad. Jag var dock rätt sparsam med den typen av asserts eftersom det blir rätt omständigt att uppdatera tester pågrund av ändringar i text i templetarna.

Det allra största "breakthough" för min del var när jag upptäckte att privata metoder kunde testas genom att placeras i Traits istället för direkt i klassen. På så sätt kunde jag use traitet av Testklassen och testa methoden med $this->. Detta gjorde att jag inte längre behövde välja mellan att ha många små publika metoder eller en stor publik som anropar många privata och nöja mig med att testa de privata metoderna enbart via den publika - nu kunde jag ha koden uppdelad i hur små bitar som helst, hålla merparten av koden privat och ändå kunna testa små delar i taget, vilket var fantastiskt och underlättade otroligt mycket i framförallt logiken kring förslag på slot/statistik där jag i samband med testning upptäckte flera brister i logiken. Denna upptäckte ledde dock även till en rätt omfattande omskrivning av koden, vilket också tog sin tid.  


Testning av databasen var relativt smidig att komma igång med, även om Symfony, som tidigare nämnt i avsnittet om Databas, betedde sig lite knasigt i vissa sammanhang - detta med att UniqueConstraintViolationException inte lyftes (misstänker att det eventuellt kan ha att göra med att jag lade till att email och acronym kolumnerna skulle vara unika direkt i databasen så Symfony kanske inte "kopierade" över dessa constraints till testdatabasen), samt att testerna i vissa fall verkade hämta ut data från riktiga databasen istället för testdatabasen, men det senare gick som sagt att komma runt detta märkliga beteende genom att uppdaterat datat i Fixtures i testdatabasen.

En annan sak som jag upplevde inte fungerade konsekvent i testning av Controllers var mockning av injectade private services. Om jag gjorde två klasser publika i services_test.yaml på precis samma sätt, och assignade de i clientens container på precis samma sätt, och mockade på precis samma sätt så kunde den ena fungera som förväntat (t ex Mock av DeckOfCards klassen vid testning av en gammal controller från Cards-uppgiften) både avseende antal gånger som viss metod förväntas bli anropas och kontroll mot returvärden. Medan den andra klassen som användes i en annan route gav felmeddelande att metoden som förväntades anropas en gång i själva verket blev anropad 0 ggr trots att Coverage filen grönmarkerade anropet, vilket ju betyder att metoden visst hade anropats. Jag kom fram till att även här är det klasser som interagerar med databasklasserna (EntityManager) som krånglar. Detta ledde också till att jag fick skriva om koden och ta bort kod som jag injectat i controllers enbart för testbarhetens skull eftersom det inte bidrog till sitt ursrpungliga ändamål. 

Sammanfattningsvis upplevde jag ordinarie klasser och traits som väldigt enkla att testa, PHP har väldigt bra stöd för mockning - bättre än Python av det jag sett hittills. Den enda nackdelen som jag upplevt är att en del metoder som varit tillgängliga tidigare (enligt chatforum) ger deprecation fel och jag lyckades inte hitta vad dessa ersatts med. Ett exempel på det är om jag vill kontrollera att en metod hos en klass anropas två gånger, först med en viss uppsättning parametrar och sedan med en annan uppsättning parametrar, så fanns det tidigare en method som hette withConsecutive, men som numera är deprecated och jag kunde inte hitta någon information om vad den ersatts med. Enbart with() blir fel eftersom den bara kan innehålla en "uppsättning" parametrar.  På andra plats kom testning av databas eftersom testerna inte alltid fungerade som förväntat. Testning av controllers var absolut svårast att komma igång med. Symfonys instruktion fungerade inte för mig rakt av utan jag behövde gå in och pilla i fler med olika inställningar enligt vägledning som jag hittat i chattforum, och även att sätta sig in i hur man testar de olika delarna (mer än att kolla selectortext och att response varit successful) har inte varit särskilt lätt. Men testerna i sig var väldigt givande - dels att jag upptäckte slarvfel i templates och felaktiga redirect i routs, och dels för att “lokalisera” exakt var logiska fel uppstod i rules metoderna (i beräkning av statistik) genom att skriva fler tester för de enskilda delarna.


#### Kodkvalitet

Jag anser att detta ska räknas in i krav 6 eftersom projektet inte innehöll några krav kring kodkvalitén och jag lade väldigt mycket tid och kraft för att hålla mig till de mätvärden som vi pratat om under kursen. Statistikberäkningen med beräkning av bästa slot bidrog till att göra denna punkt än svårare.

Jag har aktivt arbetat med kodkvalitet under hela projektets gång och kontrollerat både mot Scrutinizer och Metrics efter i princip varje ändring/tillägg. Förutom att skriva projekt-koden "rätt" från start har jag även gjort viss insats med gammal kod och nedan beskrivna betyg inkluderar samtliga klasser från både projektet och från tidigare kursmoment, inklusive Controllers och Databasklasser. Projektklasserna är (förutom databasklasserna) de som ligger i namespaces som börjar på App\Project…\ samt controllers som börjar på Project… 

Det som jag främst koncentrerat mig på i Scrutinizer är:  

1. helhetsbetyg på 10.0
2. att alla klasser/metoder ska ha A i betyg
3. Kodtäckning på 100% utan att exkludera något

[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/JuliaLind/mvc/badges/quality-score.png?b=main)](https://scrutinizer-ci.com/g/JuliaLind/mvc/?branch=main)
[![Code Coverage](https://scrutinizer-ci.com/g/JuliaLind/mvc/badges/coverage.png?b=main)](https://scrutinizer-ci.com/g/JuliaLind/mvc/?branch=main)
[![Build Status](https://scrutinizer-ci.com/g/JuliaLind/mvc/badges/build.png?b=main)](https://scrutinizer-ci.com/g/JuliaLind/mvc/build-status/main)

I Metrics har jag koncentrarat mig på:

1. Att Class Cyclomatic Complexity dvs cyklomatisk komplexitet på klassnivå  ska vara max 10 (högsta för mig ligger på 7 men merparten ligger på 1-3 iochmed att jag använder mig av många små traits)
2. Att Max Method Cycolamtic Complexity ska vara max 10, dvs metod med högsta cyclomatiska komplexiteten inom en klass (högsta för mig är 6 men de flesta ligger mellan 0-3).
3. LCOM (lack of cohesion of methods), dvs värde på klassens ansvar, där 1 motsvarar ett ansvarsområde och 2 betyder att klassen bör delas upp. jag har strävat efter max 1 och klasser som jag skapat själv ligger på 1 (förutom Exceptions som ligger på 0 eftersom de inte innehåller någon kod). De fyra autogenerarade Repository-klasserna har 2, och jag lät de vara så eftersom varje gång jag försökte att bättra på något som hade med databasklasser att göra kraschade min kod på ett eller annat sätt. Värst var det vid ett tillfälle när jag försökte att flytta klasser under Entity till andra namespaces för att få bort Packade violation i Metrics. Det verkade inte heller gå att laga genom att enbart flytta tillbaka dessa, men som tur var hade jag pushat till Github ofta och kunde därför hämta ner den senast fungerade versionen utan alltför mycekt förlorat arbete. Efter denna incident tog jag för vana att vara noga med att båda pusha och tagga senast fungerande version innan alla större ändringar. Överlag upplevde jag Github som riktigt bra arbetsverktyg. Github Actions upptäckte vid flera tillfällen fel avseende indrag, trailing speaces mm som inte verkar fångas upp av lintern i csfix kommandot och jag har verkligen uppskattat den extra kontrollen. Och såklart alla automatiska checkar av Scrutinizer vid uppladdningarna. Just när det kommer till LCOM tycker jag egentligen inte att det alltid lett till bättre kod att hålla den till ett - i flera fall resulterade det, enligt mitt tycke, i alldeles för små klasser som likväl då hade kunnat vara fristående funktion, och dessutom delar man upp kod som även om den inte direkt arbetar med samma variabler ändå "makes sence" att hållas ihop för bättre överskådlighet. 

Nedan bild visar Metircs diagram över maintainability och cyclomatisk komplexitet för samtliga klasser

<div class="no-p">
<img src="img/project/metrics-maintainability.png" alt="Metrics maintainability">  
</div>


Min ursprungliga tanke var att även få bort alla Package Violations men det gav jag snabbt upp på - dels så fick man en Stable Depencencies Principle violation så snart man försökte att dela upp en namespace i två för att få lite bättre ordning. Och dels så fick jag dessa varningar på klasser/namespaces som autogenererats av Symfony  (Repository, Entity, DataFixtures) som jag inte vågar röra på i och med att koden bakom är alladeles för abstrakt för att jag ska kunna känna mig trygg i vilka konsekvenser som varje ändring kommer att leda till. Just Stable Abstractions Principle och Stable Dependencies principle upplevde jag att vi inte pratat särskilt mycket alls om i kursen och jag hade gärna velat få tips kring hur man ska tänka för att inte få dessa varningar men ändå kunna hålla god ordning i sin kod utan att ha precis allt i en och samma mapp/namespace. Och även vad dessa varningar faktiskt innebär - spontant hade jag trott att uppdelning av kod eller återanvändning av samma klass i fler namespaces/sammanhang borde betraktas som bra, inte dåligt.  


### Projektet

De första fem kraven tyckte jag var rimliga i förhållande till projektet och den utsedda tiden. Det som tog minst tid var nog beräkning av vilka regler som är uppfyllda i händerna - vi hade redan skrivit liknande kod i samband med Jatzy spelet i Python kursen så logiken för majoriteten av reglerna var redan färdigskriven. Krav 6 var lite för otydlig - jag tyckte att det var svårt att bedöma på egen hand vilken svårighetsnivå som förväntades på lösningen för full poäng, och dessutom fanns det bara två förslag på optionella saker i den projektidén som jag valde och man behöve ha 3-5. Jag tror att krav 6 tog sammanlagt lika lång tid för mig som krav 1-5 tillsammans, om inte mer. Jag hade föredragit en tydligare kravspec, som i de övriga fem punkterna.


I slutändan är jag mycket nöjd med helhets-resultatet och den kunskapen jag tagit till mig under projektets gång. Efter projektet har jag bland annat fått bättre förståelse när det är lämpligt att använda Interface och framförallt vilka otroliga fördelar använding av traits ger. Tex så kan jag, genom att lägga privata metoder i traits, enkelt testa dessa, vilket gör att jag inte behöver välja mellan att göra de publika eller endast testa genom testning av publika metoder som anropar dessa, vilket i sin tur medför att jag kan testa små små bitar av koden enskilt och därmed underlätta felsökning framförallt när det gäller logiska fel. Detta kom särskilt till användning i testning av kod som kontrollerar om en regel är möjlig att uppfylla med det tilldelade kortet, framförallt när det kom till möjligheten till att få two pairs regeln eftersom det fanns så många olika möjliga fall att undersöka som inte gick att lägga under en och samma generella logik till skillnad från merparten av de andra reglerna.

Det som jag inte riktigt tyckte om i projekt-upplägget (förutom att krav 6 inte hade tydligare kravspec/riktlinjer) var att vi i denna kurs fortsatte på samma webbplats som me-sidan istället för att bygga helt ny. Eftersom jag valde att skriva all projektrelaterad kod från scratch så var den gamla koden/filerna bara till besvär och i vägen, både när det gällde navigering i VScode men framförallt att försöka orientera bland mättalen i kodkvalitetsverktygen, främst i diagrammet i Metrics som visar på maintainability index och där man behöver hålla muspekaren över varje cirkel för att se vilken klass eller trait den avser. Jag misstänker att det kommer kännas lika rörigt även för rättaren att skilja på vad som hör till projektet och vad som hör till de tidigare kursmomenten


### Om kursen

Generellt har jag upplevt kursen som något utspridd och att vi bara hann beröra alla nya delar tillsammans väldigt lätt, men att man ändå förväntades kunna lösa svårare saker, som vi inte gått igenom, på egen hand. Detta skilde sig från tidigare kurser där såväl ordinarie kursmoment som projekt varit varianter av det vi gått igenom tillsammans och på ungefär samma nivå.  Om jag hade fått välja hade jag velat ha det lite mer fokuserat på färre områden och att vi djupdök mer i de svårare delarna tillsammans. Framförallt kände jag att vi bara gjorde några få enkla exempel tillsammans avseende Doctrine men att man sedan förväntades kunna mycket mer än så i projektet. En sådan sak var återställning av databas -  jag misstänker att, med tanke på hur inkapslat allt annat är i Symfony, att även återställning av databas är tänkt att göras med hjälp av någon inbyggd funktionalitet i Symfony och inte som jag har löst det. Detta eftersom jag fick mocka Connection klass för att kunna skriva test för controller som återställer databasen, i annat fall läste den in Fixtures i den riktiga databasen istället för testdatabasen, varpå testet kraschade. Men det var inget som jag kunde hitta information om och överlag upplevde jag varken Doctrine eller Symfony som särskilt intuitiva att arbeta med på egen hand.

 Som helhetsbetyg är jag ändå nöjd med denna kurs. Innan kursen hade jag rätt begränsade kunskaper i php (egentligen inte mer än loopar och if/else, och jag kunde inte skapa mer avancerade funktioner är en som inte tar några parameterar och returnerar ett fast värde) och nu efter kursen känner jag mig helt bekväm med språket och skulle säga att jag kan det på samma nivå som Python och Javascript, vilket är helt klart mycket bättre än vad jag hade kunnat förvänta mig när jag började. Det absolut bästa med kursen var introduktionen till verktygen Scrutinizer och Metrics - det känns jättebra att inte behöva gissa sig till om ens kod är bra eller inte utan få det automatiskt bedömt med tydliga riktlinjer att gå efter, det underlättar arbetet väldigt mycket och det bästa hade varit om vi hade fått använda verktyget redan från kmom01 och i alla kurser (om det nu finns motsvarande verktyg för de andra språken). Att konsekvent arbeta mot verktygen under projektet har också gett mig en ganska bra bild för vad som påverkar de olika aspekterna av kodkvaliteten och vilken kod som blir lätt respektive svår att testa. 
 
 Om jag tar utgångspunkt i hur mycket jag lärt mig om PHP och kodkvalitet och vilket mervärde kodanalysverktygen kommer att ge mig även i framtida kodskrivande så ger jag kursen 10 av 10.

